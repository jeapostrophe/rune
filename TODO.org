* Rune

Rune is an "operating system" and user interface. It performs the
jobs of:
- emacs
- screen
- xterm
- zsh
- conkeror
- irsii
- google-chrome
- xmonad
- xmobar
- dmenu
- miro
- workrave
- gmail
- google calendar
- newsblur
- twitter reader
- eog
- evince
- ps
- pkill
- crond

It is generalized over a user interface, so I can easily port it from
the console, framebuffer, X11, Wayland, etc. It is designed to have a
totally functional core so its state can be easily saved and reloaded
to exactly the same environment.

It has the concepts of a process, a Web view, a canvas, a buffer, a
frame, a window, and a file.

A lot of what it does is based on the concept of overlays... where a
specific chunk of space (characters or pixels) has added information
about it.

This information might affect rendering (color) or the behavior of
other commands (so that F1 could look at the 'help overlays of where
it is).

Modes would specify parsers and lexers that add overlay information to
the content they are reading (or to other content.) For instance, the
spell-check mode would add a 'spelled-wrong overlay given that
another mode had added the 'plain-text overlay. For instance, the
compile mode might look for messages of the form "file:line: message"
and add overlay to that file. For efficiency, we make the programmer
specify things about parser/lexer behavior, such that the entire file
doesn't need to be re-lexed.

Special Rune programs can produce pre-overlayed text.

Commands could search their body for overlays of a specific type
(such as "how many words are spelled wrong?")

* Layout Tree

  A view is a cursor plus a buffer---it represents an active buffer.

  A layout is n-ary tree where branches have "styles" and the leaves
  are views. Styles are stuff like: 
  - horizontal: Children are distributed equally horizontally
  - vertical: Children are distributed equally vertically
  - tall: One child is horizontal and the other children are
    vertical
  - mirror tall: One child is vertical and the other children are
    horizontal
  - full: One child has the whole space and the other children are
    hidden
  - header: There are exactly two children, one is on top and never
    receives focus
  - footer: There are exactly two children, one is on bottom and never
    receives focus
 
 [My Xmonad setup is (header "xmobar" (full (tall ...) (tall ...)
 ...)), whereas a normal emacs window is (footer (footer (view)
 mode-line) mini-buffer)]

 A focus is a zipper of a layout.
* Tasks
** TODO Think about emacs design
   http://en.wikipedia.org/wiki/Emacs
** TODO Think about Yi design
   http://yi-editor.blogspot.com/

   http://yi-editor.blogspot.com/2009/03/lazy-and-incremental-parsing-paper.html

   http://yi-editor.blogspot.com/2008/11/incremental-parsing-in-yi.html
** TODO plan structure
   like a microkernel...
   - state manager
   - rendering manager (rendering individual windows/frames)
   - gui manager (creating X/etc windows)

   Each "mode" would get its own process and send/receive messages
   about changes, overlays, etc

   Each "window" would get its own process and send/receive messages
   about cursor movement, key inputs, etc that may send it in turn
   to...

   Each "buffer" would get its own process to facilitate safe file
   modification
** TODO implement gap buffer
** TODO what to do first?
   basic editor -> buffers/windows/frames -> multiple modes ->
   terminal -> shell -> org-mode -> canvas buffers (eog, evince) ->
   web buffers
** TODO terminal
   Make every command invocation create a new set of buffers that is
   "spliced" into the terminal buffer, so that you get a record the
   entire interaction that can be redisplayed in the future (like
   always "tee"ing)
** TODO automatically increase font-size so that 80chars fit width-wise and no more
** TODO embed chromium
   CEF3 seems to do it

   big challenge might be doing off-screen rendering and then
   figuring out where an object is to overlay on it?

** TODO integrate with anthy for JP input
